## 计算机网络 

#### HTTP和HTTPS
###### 1.什么是HTTP?

> HTTP是超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议，常基于TCP/IP协议传输数据，设计初衷是为了提供一种发布和接受HTML页面的方法。

###### 2.HTTP1.0，1.1，2.0的区别？

> + HTTP1.0 大多数实现为每个请求/响应建立新的连接。HTTP1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开连接，服务器不跟踪每个客户也不记录过去的请求。影响客户机和服务器的性能。
> + HTTP1.0若要保持长连接，则必须使用keep-alive参数，keep-alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件中设定这个时间。
> + HTTP1.1默认支持长连接，可以用来发多个请求。
> + HTTP1.1节约带宽，支持只发送header信息（不带任何body信息），如果服务器认为客户端有权限请求服务器，则返回100，否则返回401。客户端如果收到100，菜开始把请求体发送到服务器。若返回401，则客户端不再发送请求体，节约了带宽。
> + HTTP1.0是没有host域的，HTTP1.1支持这个参数（web server上的多个虚拟站点可以共享同一个IP和端口）。
> + HTTP2.0使用了多路复用，同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。
> + HTTP2.0支持数据压缩，使用HPACK算法对header的数据进行压缩，这样体积减小，传输变快。
> + HTTP2.0支持服务器推送。当我们对支持HTTP2.0的服务器请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，避免了再次创建连接请求服务器。
>

###### 3.HTTP请求报文包括？

> + 请求行：包括请求方法、请求URL、HTTP协议版本号。
> + 请求头：包含若干个属性，属性格式为key-value，value可以为多个，服务端据此获取客户端的信息。常见的属性有：Accept，如Accept:text/plain 表示客户端只接受文本信息。Cookie，catch-control.
> + 请求体：传递请求参数。

###### 4.HTTP响应报文包括？

> + 响应行：HTTP协议版本+ 状态码+原因短语
> + 响应头：包含若干个属性，属性为key-value。
> + 响应体：服务器处理请求返回的结果。

###### 5.状态码类别？

> |      |              类别              |         原因短语         |
> | :--: | :----------------------------: | :----------------------: |
> | 1XX  |  Informational(信息性状态码)   |    接受的请求正在处理    |
> | 2XX  |      Success(成功状态码)       |       请求处理成功       |
> | 3XX  |   Redirection(重定向状态码)    | 需要进行附加操作完成请求 |
> | 4XX  | Client Error(客户端错误状态码) |    服务器无法处理请求    |
> | 5XX  |   Server Error(服务器状态码)   |    服务器处理请求出错    |
>
> 100：客户端继续其请求。
>
> 101：切换协议，服务器根据客户端的请求切换协议，只能切换到更高级的协议。
>
> 200：请求成功，正常处理。
>
> 204：服务器成功处理请求，但未返回实体。
>
> 206：服务器成功处理了部分请求。
>
> 301：永久性重定向。该状态的请求资源分配了新的URL。
>
> 302：临时性重定向。本次请求使用新的URL访问。
>
> 303：与302有着相同的功能，但303表示客户端应采用GET获取资源。
>
> 400：客户端存在语法错误，服务器无法理解。
>
> 401：请求需要有认证信息。
>
> 403：服务器理解请求，但拒绝执行请求。
>
> 404：服务器无法根据请求找到对应的资源。
>
> 500：服务端在执行请求时发生了错误。
>
> 503：服务器处于超负荷或正在停机维护，无法处理请求。

###### 6.HTTP的缺点？

> + 通信使用明文，可能会被窃听。
> + 不验证通信方的身份，可能会遭遇伪装。
> + 无法验证报文的完整性，报文可能被纂改。

###### 7.HTTPS？

> + HTTPS = HTTP + SSL/TLS
> + SSL/TLS拥有加密、身份认证、完整性保护功能。
> + SSL采用公开密钥和共享密钥的混合加密方式。公开密钥是一对非对称的密钥，共享密钥是一对对称密钥。使用公开密钥加密方式安全的交换在稍后的共享密钥中要使用的密钥（公开密钥比共享密钥更为复杂，若在通信时使用公开密钥，则效率会很低），确保密钥交换安全的情况下，使用共享密钥进行通信。
> + 身份认证：服务器向认证机构提出公开密钥的申请，认证机构对公开密钥进行数字签名，将已签名的公开密钥放入公钥证书，服务器将公钥证书颁发给客户端。客户端使用公开密钥对数字签名进行验证。（多数浏览器会事先在其内部植入常用认证机关的公开密钥）
> + 完整性保护：有了加密和身份认证，完整性也得以保护。

###### 8.Web攻击技术？

> + 主动攻击：SQL注入和OS注入。
>
> + 被动攻击：跨站脚本攻击（XSS）和跨站点请求伪造。
>
> + SQL注入攻击：针对Web应用使用的数据库，通过运行非法的SQL而产生的攻击（如：在查询语句后加入'--'会自动注释掉'--'后面的语句）。SQL注入会产生一下影响：
>
>   + 非法查看或者篡改数据库内的数据。
>   + 规避认证。
>   + 执行和数据库服务器相关连的程序等。
>
> + OS命令注入攻击：通过Web应用执行非法的操作系统命令来达到攻击的目的。只要能在调用shell函数的地方就有存在被攻击的风险。
>
> + XSS攻击：通过存在安全漏洞的Web应用网站注册用户的浏览器内运行非法的HTML标签或者JavaScript进行的一种攻击。造成的影响有：
>
>   + 利用虚假表单片区用户的个人信息。
>   + 利用脚本窃取用户的cookie值，被害者在不知情的情况下，帮助攻击者发送恶意请求。
>   + 显示伪造的文章或图片。
>

#### TCP/IP

###### 1.OSI网络模型、TCP/IP、五层网络模型？

> - OSI网络模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。
> - 五层网络模型：应用层、传输层、网络层、数据链路层、物理层。
> - TCP/IP：应用层、传输层、网络层、网络接口层。
> - 物理层：实现相邻计算机节点之间 比特流透明的传送。
> - 数据链路层：将数据封装成帧、透明传输、差错检测。该层负责MAC地址，使用点对点协议，只检测差错而不修改差错。
> - 网络层：将IP地址转换为对应的物理地址，并通过路由选择算法为分组选择适当的路径。网络层提供主机间的逻辑通信。
>   - IP协议：提供不可靠的、无连接的数据传送服务。
>   - ARP（地址解析协议）：将IP地址解析成MAC地址。每个主机都会在自己的ARP缓冲去中建立一个ARP列表，表示IP地址和MAC地址之间的映射关系。每个主机发送报文时，会检测ARP列表中是否有IP地址对应的MAC地址，如果有则直接发送数据，如果没有，就像本网段的所有主机发送ARP数据包。
>   - RARP（逆地址解析协议）：将MAC地址转化为IP地址。
>   - ICMP：允许主机或路由器报告差错情况和提供有关异常情况的报告。（ping命令属于ICMP）
> - 运输层：提供应用进程之间的逻辑通信。主要协议有TCP、UDP协议。
> - 应用层：为用户的应用进程提供网络通信服务。主要协议有DNS协议。
>   - DNS：域名解析协议，将域名解析为IP地址。
>   - DNS解析过程：(1)计算机给DNS服务器发起一个请求www.baidu.com，DNS服务器会先在自己的缓存中查找有没有这个IP地址，如果有的话，直接返回；(2)如果缓存中没有的话，DNS会从配置文件中读取13个根域名服务器的地址，然后向其中一台发起请求，根服务器会返回com.顶级域的服务器IP和名称；(3)向com.域所在服务器发送请求，返回baidu.com域的服务器IP和名称；(4)向baidu.com域所在的服务器发送请求，返回www.baidu.com的IP；(5)DNS服务器将IP地址返回给客户端。

###### 2.TCP三次握手？

> + 第一次握手：客户端向服务器发送请求报文，报文中的同部位SYN=1，初始序列号为seq=x，客户端进入同步已发送状态。
> + 第二次握手：服务器收到请求后，发出确认报文，报文中SYN=1，ACK=1，确认号为ack=x+1， 初始化自己的序列为seq=y，服务器进入同步收到状态。
> + 第三次握手：客户端收到确认报文后，还要向服务器给出确认。ACK=1，ack=y+1，seq=x=1。服务器收到报文后，建立连接。

###### 3.为什么需要三次握手？

> 为了防止已失效的连接请求报文突然传到服务器端，从而产生错误。
>
> 假如采用两次握手，现在有这么一种情况：客户端发送了一个请求，因为网络延迟而没有传到服务器，客户端因为迟迟没有接收到服务端的确认报文，于是再次发送请求，然后通过两次握手建立连接。此时，网络通畅，之前滞留的请求发送到了服务端 ，通过两次握手建立连接，造成不必要的错误和资源浪费。如果采用三次握手，即使那条失效的报文传到服务端，服务端向客户端发送了确认报文，客户端也不会再次发出确认，因此不会建立连接。

###### 4.TCP四次挥手？

> + 第一次挥手：客户端发送连接释放报文，FIN=1，seq=u，进入终止等待1状态。
>
> + 第二次挥手：服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，seq=v，服务器进入关闭等待状态（TCP是全双工通信）。此时TCP处于半关闭状态，客户端已经没有数据要发送了，但服务器若发送数据，客户端必须接受，这个状态要持续一段时间。
>
>   客户端收到确认报文后，进入终止等待2状态。
>
> + 第三次挥手：服务器发送连接释放报文，FIN=1，ack=u+1，服务器进入最后确认状态。
>
> + 第四次挥手：客户端收到服务器的连接释放报文后，发出确认报文，ACK=1，ack=w+1，seq=u+1，客户端进入TIME-WAIT状态。此时连接并没有释放，必须经过2*MSL时间，客户端进入CLOSED状态，服务器收到确认报文后，进入CLOSED状态，关闭连接。

